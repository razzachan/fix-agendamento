<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix Fog√µes - Verifica√ß√£o Pr√©-Limpeza</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #E5B034 0%, #f39c12 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        .header p {
            margin: 10px 0 0 0;
            opacity: 0.9;
            font-size: 1.1em;
        }
        .content {
            padding: 30px;
        }
        .section {
            margin-bottom: 40px;
            padding: 25px;
            border-radius: 10px;
            background: #f8f9fa;
            border-left: 5px solid #E5B034;
        }
        .section h2 {
            margin: 0 0 20px 0;
            color: #2c3e50;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }
        .section h2::before {
            content: "üìä";
            margin-right: 10px;
            font-size: 1.2em;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.2s;
        }
        .stat-card:hover {
            transform: translateY(-2px);
        }
        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #E5B034;
            margin: 10px 0;
        }
        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #856404;
        }
        .warning::before {
            content: "‚ö†Ô∏è ";
            font-size: 1.2em;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #155724;
        }
        .success::before {
            content: "‚úÖ ";
            font-size: 1.2em;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
        }
        .loading::before {
            content: "üîÑ ";
            font-size: 1.5em;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            color: #721c24;
        }
        .error::before {
            content: "‚ùå ";
            font-size: 1.2em;
        }
        .button {
            background: linear-gradient(135deg, #E5B034 0%, #f39c12 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s;
            margin: 10px;
        }
        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(229, 176, 52, 0.4);
        }
        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .button.danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }
        .button.danger:hover {
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }
        .table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .table th, .table td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid #ecf0f1;
        }
        .table th {
            background: #34495e;
            color: white;
            font-weight: 600;
        }
        .table tr:hover {
            background: #f8f9fa;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Verifica√ß√£o Pr√©-Limpeza</h1>
            <p>Fix Fog√µes - An√°lise dos dados antes da exclus√£o</p>
        </div>
        
        <div class="content">
            <div class="warning">
                <strong>IMPORTANTE:</strong> Esta verifica√ß√£o analisa todos os dados que ser√£o removidos durante a limpeza. 
                Revise cuidadosamente antes de prosseguir com a exclus√£o.
            </div>
            
            <div style="text-align: center; margin-bottom: 30px;">
                <button class="button" onclick="startVerification()">üöÄ Iniciar Verifica√ß√£o</button>
                <button class="button" onclick="createBackup()" id="backupBtn" style="display: none;">üíæ Criar Backup</button>
                <button class="button danger" onclick="cleanDatabase()" id="cleanBtn" style="display: none;">üóëÔ∏è Limpar Banco de Dados</button>
                <button class="button danger" onclick="executeSQLCleanup()" id="sqlCleanBtn" style="display: none;">üî• Limpeza SQL Direta</button>
                <button class="button" onclick="cleanStorage()" id="storageBtn" style="display: none;">üìÅ Limpar Storage</button>
            </div>

            <div id="progress" style="display: none;">
                <div class="section">
                    <h2>Progresso da Limpeza</h2>
                    <div id="progressContent"></div>
                </div>
            </div>

            <div id="results">
                <!-- Resultados ser√£o inseridos aqui -->
            </div>
        </div>
    </div>

    <script type="module">
        import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

        const supabaseUrl = 'https://hdyucwabemspehokoiks.supabase.co'
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhkeXVjd2FiZW1zcGVob2tvaWtzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDQwNDA3NjksImV4cCI6MjA1OTYxNjc2OX0.koJXDLh4_rEGGMFB_7JrtXj9S7JTSGxPtrozhjWoS3M'

        const supabase = createClient(supabaseUrl, supabaseKey)

        window.startVerification = async function() {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = '<div class="loading">Executando verifica√ß√£o completa...</div>';
            
            try {
                let html = '';
                
                // 1. Contagem geral de registros
                html += await getGeneralCounts();
                
                // 2. An√°lise de depend√™ncias
                html += await getDependenciesAnalysis();
                
                // 3. An√°lise de clientes
                html += await getClientsAnalysis();
                
                // 4. An√°lise por status
                html += await getStatusAnalysis();
                
                // 5. An√°lise por tipo de atendimento
                html += await getAttendanceTypeAnalysis();
                
                // 6. Resumo final
                html += await getFinalSummary();
                
                resultsDiv.innerHTML = html;

                // Mostrar bot√µes de a√ß√£o ap√≥s verifica√ß√£o bem-sucedida
                document.getElementById('backupBtn').style.display = 'inline-block';

            } catch (error) {
                console.error('Erro na verifica√ß√£o:', error);
                resultsDiv.innerHTML = `<div class="error">Erro ao executar verifica√ß√£o: ${error.message}</div>`;
            }
        }

        // Fun√ß√£o para criar backup
        window.createBackup = async function() {
            const progressDiv = document.getElementById('progress');
            const progressContent = document.getElementById('progressContent');

            progressDiv.style.display = 'block';
            progressContent.innerHTML = '<div class="loading">Criando backup dos dados...</div>';

            try {
                let backupResults = [];

                // 1. Backup das ordens de servi√ßo
                progressContent.innerHTML = '<div class="loading">Fazendo backup das ordens de servi√ßo...</div>';
                const ordersBackup = await createTableBackup('service_orders', 'backup_service_orders');
                backupResults.push(`Ordens de servi√ßo: ${ordersBackup.count} registros`);

                // 2. Backup das imagens
                progressContent.innerHTML = '<div class="loading">Fazendo backup das imagens...</div>';
                const imagesBackup = await createTableBackup('service_order_images', 'backup_service_order_images');
                backupResults.push(`Imagens: ${imagesBackup.count} registros`);

                // 3. Backup dos coment√°rios
                progressContent.innerHTML = '<div class="loading">Fazendo backup dos coment√°rios...</div>';
                const commentsBackup = await createTableBackup('service_order_comments', 'backup_service_order_comments');
                backupResults.push(`Coment√°rios: ${commentsBackup.count} registros`);

                // 4. Backup de outros dados relacionados
                const otherTables = [
                    'service_order_progress',
                    'service_events',
                    'financial_transactions',
                    'agendamentos_ai'
                ];

                for (const table of otherTables) {
                    try {
                        progressContent.innerHTML = `<div class="loading">Fazendo backup de ${table}...</div>`;
                        const backup = await createTableBackup(table, `backup_${table}`);
                        if (backup.count > 0) {
                            backupResults.push(`${table}: ${backup.count} registros`);
                        }
                    } catch (error) {
                        console.warn(`Tabela ${table} n√£o encontrada ou erro:`, error);
                    }
                }

                progressContent.innerHTML = `
                    <div class="success">
                        <strong>‚úÖ Backup criado com sucesso!</strong><br><br>
                        <strong>Dados salvos em backup:</strong>
                        <ul>
                            ${backupResults.map(result => `<li>${result}</li>`).join('')}
                        </ul>
                        <br>
                        <strong>üìã Agora voc√™ pode prosseguir com a limpeza do banco de dados.</strong>
                    </div>
                `;

                // Mostrar bot√µes de limpeza
                document.getElementById('cleanBtn').style.display = 'inline-block';
                document.getElementById('sqlCleanBtn').style.display = 'inline-block';
                document.getElementById('backupBtn').style.display = 'none';

            } catch (error) {
                console.error('Erro no backup:', error);
                progressContent.innerHTML = `<div class="error">Erro ao criar backup: ${error.message}</div>`;
            }
        }

        // Fun√ß√£o auxiliar para criar backup de uma tabela
        async function createTableBackup(sourceTable, backupTable) {
            try {
                // Primeiro, obter todos os dados da tabela original
                const { data, error: selectError } = await supabase
                    .from(sourceTable)
                    .select('*');

                if (selectError) throw selectError;

                if (!data || data.length === 0) {
                    return { count: 0 };
                }

                // Criar a tabela de backup inserindo os dados
                // Nota: Como n√£o podemos criar tabelas via API REST, vamos salvar os dados em localStorage
                localStorage.setItem(backupTable, JSON.stringify(data));

                return { count: data.length };

            } catch (error) {
                console.error(`Erro ao fazer backup de ${sourceTable}:`, error);
                return { count: 0 };
            }
        }

        // Fun√ß√£o para limpar banco de dados
        window.cleanDatabase = async function() {
            const progressContent = document.getElementById('progressContent');

            // Confirma√ß√£o de seguran√ßa
            const confirmation = confirm(
                '‚ö†Ô∏è ATEN√á√ÉO: Esta a√ß√£o ir√° DELETAR PERMANENTEMENTE todos os dados!\n\n' +
                '‚úÖ Backup foi criado\n' +
                'üóëÔ∏è 17 ordens de servi√ßo ser√£o removidas\n' +
                'üóëÔ∏è Todos os dados relacionados ser√£o removidos\n\n' +
                'Tem certeza que deseja continuar?'
            );

            if (!confirmation) {
                return;
            }

            try {
                let deletionResults = [];

                // ORDEM CORRETA: Deletar depend√™ncias ANTES das ordens principais

                // 1. Deletar coment√°rios das ordens
                progressContent.innerHTML = '<div class="loading">Removendo coment√°rios das ordens...</div>';
                const commentsDeleted = await deleteAllFromTable('service_order_comments');
                if (commentsDeleted > 0) deletionResults.push(`Coment√°rios: ${commentsDeleted} removidos`);

                // 2. Deletar imagens das ordens
                progressContent.innerHTML = '<div class="loading">Removendo imagens das ordens...</div>';
                const imagesDeleted = await deleteAllFromTable('service_order_images');
                if (imagesDeleted > 0) deletionResults.push(`Imagens: ${imagesDeleted} removidas`);

                // 3. Deletar progresso das ordens
                progressContent.innerHTML = '<div class="loading">Removendo registros de progresso...</div>';
                const progressDeleted = await deleteAllFromTable('service_order_progress');
                if (progressDeleted > 0) deletionResults.push(`Progresso: ${progressDeleted} removidos`);

                // 4. Deletar eventos das ordens (CR√çTICO: antes das ordens!)
                progressContent.innerHTML = '<div class="loading">Removendo eventos das ordens...</div>';
                const eventsDeleted = await forceDeleteServiceEvents();
                if (eventsDeleted > 0) deletionResults.push(`Eventos: ${eventsDeleted} removidos`);

                // 5. Deletar transa√ß√µes financeiras
                progressContent.innerHTML = '<div class="loading">Removendo transa√ß√µes financeiras...</div>';
                const transactionsDeleted = await deleteAllFromTable('financial_transactions');
                if (transactionsDeleted > 0) deletionResults.push(`Transa√ß√µes: ${transactionsDeleted} removidas`);

                // 6. Deletar agendamentos AI
                progressContent.innerHTML = '<div class="loading">Removendo agendamentos AI...</div>';
                const schedulesDeleted = await deleteAllFromTable('agendamentos_ai');
                if (schedulesDeleted > 0) deletionResults.push(`Agendamentos AI: ${schedulesDeleted} removidos`);

                // 7. Deletar diagn√≥sticos (se existirem)
                progressContent.innerHTML = '<div class="loading">Removendo diagn√≥sticos...</div>';
                try {
                    const diagnosesDeleted = await deleteAllFromTable('diagnoses');
                    if (diagnosesDeleted > 0) deletionResults.push(`Diagn√≥sticos: ${diagnosesDeleted} removidos`);
                } catch (error) {
                    console.warn('Tabela diagnoses n√£o encontrada ou erro:', error);
                }

                // 8. Deletar a√ß√µes requeridas (se existirem)
                progressContent.innerHTML = '<div class="loading">Removendo a√ß√µes requeridas...</div>';
                try {
                    const actionsDeleted = await deleteAllFromTable('required_actions');
                    if (actionsDeleted > 0) deletionResults.push(`A√ß√µes requeridas: ${actionsDeleted} removidas`);
                } catch (error) {
                    console.warn('Tabela required_actions n√£o encontrada ou erro:', error);
                }

                // 9. Deletar avalia√ß√µes de clientes (se existirem)
                progressContent.innerHTML = '<div class="loading">Removendo avalia√ß√µes de clientes...</div>';
                try {
                    const ratingsDeleted = await deleteAllFromTable('customer_ratings');
                    if (ratingsDeleted > 0) deletionResults.push(`Avalia√ß√µes: ${ratingsDeleted} removidas`);
                } catch (error) {
                    console.warn('Tabela customer_ratings n√£o encontrada ou erro:', error);
                }

                // 10. Deletar notifica√ß√µes relacionadas (se existirem)
                progressContent.innerHTML = '<div class="loading">Removendo notifica√ß√µes...</div>';
                try {
                    const notificationsDeleted = await deleteAllFromTable('notifications');
                    if (notificationsDeleted > 0) deletionResults.push(`Notifica√ß√µes: ${notificationsDeleted} removidas`);
                } catch (error) {
                    console.warn('Tabela notifications n√£o encontrada ou erro:', error);
                }

                // 11. VERIFICA√á√ÉO FINAL E LIMPEZA FOR√áADA antes de deletar ordens
                progressContent.innerHTML = '<div class="loading">üîç Verifica√ß√£o final e limpeza for√ßada...</div>';
                await verifyNoDependencies();

                // 11.5. FOR√áA FINAL: Deletar service_events usando SQL direto
                progressContent.innerHTML = '<div class="loading">üî• Limpeza for√ßada final de service_events...</div>';
                await forceDeleteServiceEventsSQL();

                // 12. AGORA SIM: Deletar as ordens de servi√ßo (ap√≥s todas as depend√™ncias)
                progressContent.innerHTML = '<div class="loading">Removendo ordens de servi√ßo...</div>';
                const ordersDeleted = await deleteServiceOrdersForced();
                deletionResults.push(`Ordens de servi√ßo: ${ordersDeleted} removidas`);

                // 12. Deletar clientes (se existirem)
                progressContent.innerHTML = '<div class="loading">Removendo clientes...</div>';
                const clientsDeleted = await deleteAllFromTable('clients');
                if (clientsDeleted > 0) deletionResults.push(`Clientes: ${clientsDeleted} removidos`);

                progressContent.innerHTML = `
                    <div class="success">
                        <strong>üéâ Limpeza do banco de dados conclu√≠da com sucesso!</strong><br><br>
                        <strong>Dados removidos:</strong>
                        <ul>
                            ${deletionResults.map(result => `<li>${result}</li>`).join('')}
                        </ul>
                        <br>
                        <strong>üìÅ Agora voc√™ pode limpar o Storage (imagens).</strong>
                    </div>
                `;

                // Mostrar bot√£o de limpeza do storage
                document.getElementById('storageBtn').style.display = 'inline-block';
                document.getElementById('cleanBtn').style.display = 'none';

            } catch (error) {
                console.error('Erro na limpeza:', error);
                progressContent.innerHTML = `<div class="error">Erro durante a limpeza: ${error.message}</div>`;
            }
        }

        // Fun√ß√£o especializada para for√ßar exclus√£o de service_events
        async function forceDeleteServiceEvents() {
            try {
                progressContent.innerHTML = '<div class="loading">üîç Investigando service_events...</div>';

                let totalDeleted = 0;
                let attempts = 0;
                const maxAttempts = 10;

                while (attempts < maxAttempts) {
                    attempts++;

                    // Verificar quantos eventos ainda existem
                    const { count: remainingEvents, error: countError } = await supabase
                        .from('service_events')
                        .select('*', { count: 'exact', head: true });

                    if (countError) {
                        console.warn('Tabela service_events n√£o encontrada:', countError);
                        return totalDeleted;
                    }

                    if (!remainingEvents || remainingEvents === 0) {
                        console.log(`‚úÖ Todos os eventos deletados! Total: ${totalDeleted}`);
                        return totalDeleted;
                    }

                    console.log(`üîÑ Tentativa ${attempts}: ${remainingEvents} eventos restantes`);
                    progressContent.innerHTML = `<div class="loading">üóëÔ∏è Tentativa ${attempts}: Deletando ${remainingEvents} eventos...</div>`;

                    // Buscar todos os eventos existentes
                    const { data: allEvents, error: fetchError } = await supabase
                        .from('service_events')
                        .select('id, service_order_id')
                        .limit(1000);

                    if (fetchError) {
                        console.error('Erro ao buscar eventos:', fetchError);
                        break;
                    }

                    if (!allEvents || allEvents.length === 0) {
                        console.log('‚úÖ Nenhum evento encontrado para deletar');
                        break;
                    }

                    console.log(`üéØ Encontrados ${allEvents.length} eventos para deletar`);

                    // Estrat√©gia AGRESSIVA: Deletar um por um
                    let deletedInThisRound = 0;

                    for (let i = 0; i < allEvents.length; i++) {
                        const event = allEvents[i];

                        try {
                            // Tentar m√∫ltiplas abordagens para cada evento
                            let deleted = false;

                            // Abordagem 1: Deletar por ID
                            try {
                                const { error: deleteByIdError } = await supabase
                                    .from('service_events')
                                    .delete()
                                    .eq('id', event.id);

                                if (!deleteByIdError) {
                                    deleted = true;
                                    deletedInThisRound++;
                                    totalDeleted++;
                                }
                            } catch (idError) {
                                console.warn(`Erro ao deletar por ID ${event.id}:`, idError);
                            }

                            // Abordagem 2: Se falhou, tentar por service_order_id
                            if (!deleted && event.service_order_id) {
                                try {
                                    const { error: deleteByOrderError } = await supabase
                                        .from('service_events')
                                        .delete()
                                        .eq('service_order_id', event.service_order_id)
                                        .eq('id', event.id);

                                    if (!deleteByOrderError) {
                                        deleted = true;
                                        deletedInThisRound++;
                                        totalDeleted++;
                                    }
                                } catch (orderError) {
                                    console.warn(`Erro ao deletar por order_id ${event.service_order_id}:`, orderError);
                                }
                            }

                            // Abordagem 3: For√ßar com condi√ß√µes m√∫ltiplas
                            if (!deleted) {
                                try {
                                    const { error: forceError } = await supabase
                                        .from('service_events')
                                        .delete()
                                        .eq('id', event.id)
                                        .neq('created_at', '1900-01-01T00:00:00Z');

                                    if (!forceError) {
                                        deleted = true;
                                        deletedInThisRound++;
                                        totalDeleted++;
                                    }
                                } catch (forceError) {
                                    console.warn(`Erro ao for√ßar exclus√£o ${event.id}:`, forceError);
                                }
                            }

                            if (deleted) {
                                console.log(`‚úÖ Evento ${event.id} deletado (${i + 1}/${allEvents.length})`);
                            } else {
                                console.warn(`‚ùå N√£o foi poss√≠vel deletar evento ${event.id}`);
                            }

                            // Pequena pausa para evitar sobrecarga
                            if (i % 10 === 0) {
                                await new Promise(resolve => setTimeout(resolve, 100));
                                progressContent.innerHTML = `<div class="loading">üóëÔ∏è Tentativa ${attempts}: ${i + 1}/${allEvents.length} eventos processados...</div>`;
                            }

                        } catch (eventError) {
                            console.error(`Erro cr√≠tico ao processar evento ${event.id}:`, eventError);
                        }
                    }

                    console.log(`üîÑ Rodada ${attempts}: ${deletedInThisRound} eventos deletados`);

                    // Se n√£o conseguiu deletar nenhum nesta rodada, parar
                    if (deletedInThisRound === 0) {
                        console.warn('‚ö†Ô∏è Nenhum evento foi deletado nesta rodada, parando tentativas');
                        break;
                    }

                    // Pausa entre tentativas
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                console.log(`‚úÖ Total final de eventos deletados: ${totalDeleted}`);
                return totalDeleted;

            } catch (error) {
                console.error('‚ùå Erro cr√≠tico ao deletar service_events:', error);
                throw error;
            }
        }

        // Fun√ß√£o para for√ßar exclus√£o de service_events usando abordagem SQL
        async function forceDeleteServiceEventsSQL() {
            try {
                console.log('üî• Iniciando limpeza for√ßada de service_events...');

                // Tentar m√∫ltiplas abordagens SQL-like
                const deleteStrategies = [
                    // Estrat√©gia 1: Deletar todos sem condi√ß√µes
                    async () => {
                        const { error } = await supabase
                            .from('service_events')
                            .delete()
                            .gte('id', '00000000-0000-0000-0000-000000000000');
                        return error;
                    },

                    // Estrat√©gia 2: Deletar com condi√ß√£o de data
                    async () => {
                        const { error } = await supabase
                            .from('service_events')
                            .delete()
                            .gte('created_at', '1900-01-01T00:00:00Z');
                        return error;
                    },

                    // Estrat√©gia 3: Deletar com condi√ß√£o NOT NULL
                    async () => {
                        const { error } = await supabase
                            .from('service_events')
                            .delete()
                            .not('id', 'is', null);
                        return error;
                    },

                    // Estrat√©gia 4: Deletar usando RPC (se dispon√≠vel)
                    async () => {
                        try {
                            const { error } = await supabase.rpc('delete_all_service_events');
                            return error;
                        } catch (rpcError) {
                            return rpcError;
                        }
                    }
                ];

                for (let i = 0; i < deleteStrategies.length; i++) {
                    try {
                        console.log(`üî• Tentando estrat√©gia SQL ${i + 1}...`);
                        const error = await deleteStrategies[i]();

                        if (!error) {
                            console.log(`‚úÖ Estrat√©gia SQL ${i + 1} funcionou!`);

                            // Verificar se realmente deletou
                            const { count } = await supabase
                                .from('service_events')
                                .select('*', { count: 'exact', head: true });

                            if (!count || count === 0) {
                                console.log('‚úÖ service_events completamente limpo!');
                                return true;
                            } else {
                                console.warn(`‚ö†Ô∏è Ainda restam ${count} eventos ap√≥s estrat√©gia ${i + 1}`);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Estrat√©gia SQL ${i + 1} falhou:`, error);
                        }
                    } catch (strategyError) {
                        console.warn(`‚ö†Ô∏è Exce√ß√£o na estrat√©gia SQL ${i + 1}:`, strategyError);
                    }
                }

                console.log('‚ö†Ô∏è Todas as estrat√©gias SQL falharam');
                return false;

            } catch (error) {
                console.error('‚ùå Erro cr√≠tico na limpeza for√ßada SQL:', error);
                return false;
            }
        }

        // Fun√ß√£o especializada para deletar service_orders
        async function deleteServiceOrdersForced() {
            try {
                console.log('üéØ Iniciando exclus√£o for√ßada de service_orders...');

                // Primeiro, verificar se service_events est√° realmente vazio
                const { count: eventsCount } = await supabase
                    .from('service_events')
                    .select('*', { count: 'exact', head: true });

                if (eventsCount && eventsCount > 0) {
                    console.error(`‚ùå AINDA EXISTEM ${eventsCount} EVENTOS! N√£o √© seguro deletar ordens.`);
                    throw new Error(`Ainda existem ${eventsCount} eventos em service_events`);
                }

                console.log('‚úÖ service_events confirmado como vazio, prosseguindo...');

                // Contar ordens
                const { count: ordersCount } = await supabase
                    .from('service_orders')
                    .select('*', { count: 'exact', head: true });

                if (!ordersCount || ordersCount === 0) {
                    console.log('‚úÖ Nenhuma ordem para deletar');
                    return 0;
                }

                console.log(`üéØ Deletando ${ordersCount} ordens de servi√ßo...`);

                // Estrat√©gias para deletar ordens
                const orderDeleteStrategies = [
                    // Estrat√©gia 1: Deletar todas de uma vez
                    async () => {
                        const { error } = await supabase
                            .from('service_orders')
                            .delete()
                            .neq('id', '00000000-0000-0000-0000-000000000000');
                        return error;
                    },

                    // Estrat√©gia 2: Deletar por lotes pequenos
                    async () => {
                        let totalDeleted = 0;

                        while (totalDeleted < ordersCount) {
                            const { data: batch } = await supabase
                                .from('service_orders')
                                .select('id')
                                .limit(5);

                            if (!batch || batch.length === 0) break;

                            const { error } = await supabase
                                .from('service_orders')
                                .delete()
                                .in('id', batch.map(o => o.id));

                            if (error) return error;

                            totalDeleted += batch.length;
                            console.log(`üîÑ ${totalDeleted}/${ordersCount} ordens deletadas...`);

                            await new Promise(resolve => setTimeout(resolve, 200));
                        }

                        return null;
                    },

                    // Estrat√©gia 3: Deletar uma por uma
                    async () => {
                        const { data: allOrders } = await supabase
                            .from('service_orders')
                            .select('id');

                        if (!allOrders) return new Error('N√£o foi poss√≠vel buscar ordens');

                        for (let i = 0; i < allOrders.length; i++) {
                            const { error } = await supabase
                                .from('service_orders')
                                .delete()
                                .eq('id', allOrders[i].id);

                            if (error) {
                                console.warn(`Erro ao deletar ordem ${allOrders[i].id}:`, error);
                                return error;
                            }

                            if (i % 5 === 0) {
                                console.log(`üîÑ ${i + 1}/${allOrders.length} ordens processadas...`);
                            }
                        }

                        return null;
                    }
                ];

                for (let i = 0; i < orderDeleteStrategies.length; i++) {
                    try {
                        console.log(`üéØ Tentando estrat√©gia de ordens ${i + 1}...`);
                        const error = await orderDeleteStrategies[i]();

                        if (!error) {
                            console.log(`‚úÖ Estrat√©gia de ordens ${i + 1} funcionou!`);

                            // Verificar se realmente deletou
                            const { count: remainingOrders } = await supabase
                                .from('service_orders')
                                .select('*', { count: 'exact', head: true });

                            if (!remainingOrders || remainingOrders === 0) {
                                console.log('‚úÖ Todas as ordens deletadas com sucesso!');
                                return ordersCount;
                            } else {
                                console.warn(`‚ö†Ô∏è Ainda restam ${remainingOrders} ordens ap√≥s estrat√©gia ${i + 1}`);
                            }
                        } else {
                            console.warn(`‚ö†Ô∏è Estrat√©gia de ordens ${i + 1} falhou:`, error);
                        }
                    } catch (strategyError) {
                        console.warn(`‚ö†Ô∏è Exce√ß√£o na estrat√©gia de ordens ${i + 1}:`, strategyError);
                    }
                }

                throw new Error('Todas as estrat√©gias de exclus√£o de ordens falharam');

            } catch (error) {
                console.error('‚ùå Erro cr√≠tico ao deletar service_orders:', error);
                throw error;
            }
        }

        // Fun√ß√£o para verificar se n√£o h√° depend√™ncias restantes
        async function verifyNoDependencies() {
            const dependentTables = [
                'service_events',
                'service_order_comments',
                'service_order_images',
                'service_order_progress',
                'financial_transactions',
                'agendamentos_ai',
                'diagnoses',
                'required_actions',
                'customer_ratings'
            ];

            console.log('üîç Verificando depend√™ncias restantes...');

            for (const table of dependentTables) {
                try {
                    const { count, error } = await supabase
                        .from(table)
                        .select('*', { count: 'exact', head: true });

                    if (!error && count && count > 0) {
                        console.warn(`‚ö†Ô∏è ATEN√á√ÉO: ${table} ainda tem ${count} registros!`);

                        // Tentar for√ßar exclus√£o uma √∫ltima vez
                        try {
                            await supabase
                                .from(table)
                                .delete()
                                .neq('id', '00000000-0000-0000-0000-000000000000');
                            console.log(`‚úÖ For√ßada exclus√£o final de ${table}`);
                        } catch (forceError) {
                            console.error(`‚ùå N√£o foi poss√≠vel for√ßar exclus√£o de ${table}:`, forceError);
                        }
                    } else {
                        console.log(`‚úÖ ${table}: limpo`);
                    }
                } catch (error) {
                    console.log(`‚ÑπÔ∏è ${table}: n√£o encontrado ou erro (normal)`);
                }
            }

            console.log('‚úÖ Verifica√ß√£o de depend√™ncias conclu√≠da');
        }

        // Fun√ß√£o auxiliar para deletar todos os registros de uma tabela
        async function deleteAllFromTable(tableName) {
            try {
                // Primeiro, contar quantos registros existem
                const { count, error: countError } = await supabase
                    .from(tableName)
                    .select('*', { count: 'exact', head: true });

                if (countError) {
                    console.warn(`Tabela ${tableName} n√£o encontrada ou erro na contagem:`, countError);
                    return 0;
                }

                if (!count || count === 0) {
                    console.log(`Tabela ${tableName} est√° vazia`);
                    return 0;
                }

                console.log(`Deletando ${count} registros de ${tableName}`);

                // Estrat√©gia mais robusta: deletar em lotes pequenos para evitar timeouts
                let totalDeleted = 0;
                let attempts = 0;
                const maxAttempts = 5;

                while (totalDeleted < count && attempts < maxAttempts) {
                    attempts++;

                    try {
                        // Deletar em lotes de 100 registros por vez
                        const { data: batch, error: selectError } = await supabase
                            .from(tableName)
                            .select('id')
                            .limit(100);

                        if (selectError) throw selectError;

                        if (!batch || batch.length === 0) {
                            break; // N√£o h√° mais registros
                        }

                        // Deletar este lote
                        const ids = batch.map(item => item.id);
                        const { error: deleteError } = await supabase
                            .from(tableName)
                            .delete()
                            .in('id', ids);

                        if (deleteError) throw deleteError;

                        totalDeleted += batch.length;
                        console.log(`${tableName}: ${totalDeleted}/${count} registros deletados`);

                        // Pequena pausa para evitar sobrecarga
                        await new Promise(resolve => setTimeout(resolve, 100));

                    } catch (batchError) {
                        console.error(`Erro no lote ${attempts} de ${tableName}:`, batchError);

                        if (attempts >= maxAttempts) {
                            throw batchError;
                        }

                        // Pausa maior antes de tentar novamente
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                console.log(`‚úÖ ${tableName}: ${totalDeleted} registros deletados com sucesso`);
                return totalDeleted;

            } catch (error) {
                console.error(`‚ùå Erro ao deletar de ${tableName}:`, error);

                // Se for erro de constraint, tentar uma abordagem diferente
                if (error.message && error.message.includes('foreign key constraint')) {
                    console.warn(`‚ö†Ô∏è Constraint detectada em ${tableName}, tentando abordagem alternativa...`);

                    try {
                        // Tentar deletar usando uma condi√ß√£o mais espec√≠fica
                        const { error: altDeleteError } = await supabase
                            .from(tableName)
                            .delete()
                            .not('id', 'is', null);

                        if (altDeleteError) throw altDeleteError;

                        console.log(`‚úÖ ${tableName}: Deletado com abordagem alternativa`);
                        return count || 0;

                    } catch (altError) {
                        console.error(`‚ùå Abordagem alternativa falhou para ${tableName}:`, altError);
                        throw altError;
                    }
                }

                throw error;
            }
        }

        // Fun√ß√£o especial para deletar service_events (mais agressiva)
        async function handleServiceEventsSpecial(tableInfo, results) {
            console.log('üî• Iniciando estrat√©gia especial para service_events...');

            try {
                // Primeiro, verificar quantos eventos existem
                const { count: initialCount } = await supabase
                    .from('service_events')
                    .select('*', { count: 'exact', head: true });

                console.log(`üìä service_events inicial: ${initialCount || 0} registros`);

                if (!initialCount || initialCount === 0) {
                    results.push(`‚úÖ ${tableInfo.name}: J√° estava vazio`);
                    return;
                }

                // Estrat√©gias ultra-agressivas para service_events
                const strategies = [
                    // Estrat√©gia 1: Buscar todos e deletar um por um
                    async () => {
                        console.log('üéØ Estrat√©gia 1: Deletar um por um...');
                        const { data: allEvents } = await supabase
                            .from('service_events')
                            .select('id');

                        if (!allEvents || allEvents.length === 0) return true;

                        let deletedCount = 0;
                        for (const event of allEvents) {
                            const { error } = await supabase
                                .from('service_events')
                                .delete()
                                .eq('id', event.id);

                            if (!error) deletedCount++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        console.log(`üéØ Deletados individualmente: ${deletedCount}/${allEvents.length}`);
                        return deletedCount === allEvents.length;
                    },

                    // Estrat√©gia 2: Deletar por lotes pequenos
                    async () => {
                        console.log('üéØ Estrat√©gia 2: Deletar por lotes...');
                        let totalDeleted = 0;

                        while (true) {
                            const { data: batch } = await supabase
                                .from('service_events')
                                .select('id')
                                .limit(5);

                            if (!batch || batch.length === 0) break;

                            const { error } = await supabase
                                .from('service_events')
                                .delete()
                                .in('id', batch.map(e => e.id));

                            if (error) {
                                console.warn('Erro no lote:', error);
                                break;
                            }

                            totalDeleted += batch.length;
                            console.log(`üîÑ Lote deletado: ${totalDeleted} eventos...`);

                            await new Promise(resolve => setTimeout(resolve, 200));
                        }

                        return totalDeleted > 0;
                    },

                    // Estrat√©gia 3: Deletar por service_order_id
                    async () => {
                        console.log('üéØ Estrat√©gia 3: Deletar por service_order_id...');

                        // Buscar todos os service_order_ids √∫nicos
                        const { data: uniqueOrders } = await supabase
                            .from('service_events')
                            .select('service_order_id');

                        if (!uniqueOrders) return false;

                        const uniqueOrderIds = [...new Set(uniqueOrders.map(e => e.service_order_id))];
                        let deletedOrders = 0;

                        for (const orderId of uniqueOrderIds) {
                            const { error } = await supabase
                                .from('service_events')
                                .delete()
                                .eq('service_order_id', orderId);

                            if (!error) deletedOrders++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        console.log(`üéØ Deletados por order_id: ${deletedOrders}/${uniqueOrderIds.length}`);
                        return deletedOrders > 0;
                    },

                    // Estrat√©gia 4: Deletar por tipo de evento
                    async () => {
                        console.log('üéØ Estrat√©gia 4: Deletar por tipo...');

                        const eventTypes = ['created', 'updated', 'status_changed', 'completed', 'cancelled'];
                        let deletedTypes = 0;

                        for (const eventType of eventTypes) {
                            const { error } = await supabase
                                .from('service_events')
                                .delete()
                                .eq('event_type', eventType);

                            if (!error) deletedTypes++;
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }

                        // Deletar eventos sem tipo espec√≠fico
                        await supabase
                            .from('service_events')
                            .delete()
                            .not('event_type', 'in', eventTypes);

                        return deletedTypes > 0;
                    }
                ];

                // Executar estrat√©gias uma por uma at√© funcionar
                for (let i = 0; i < strategies.length; i++) {
                    try {
                        console.log(`üî• Executando estrat√©gia ${i + 1} para service_events...`);

                        const success = await strategies[i]();

                        // Verificar se realmente deletou
                        const { count: remainingCount } = await supabase
                            .from('service_events')
                            .select('*', { count: 'exact', head: true });

                        console.log(`üìä Ap√≥s estrat√©gia ${i + 1}: ${remainingCount || 0} eventos restantes`);

                        if (!remainingCount || remainingCount === 0) {
                            results.push(`‚úÖ ${tableInfo.name}: Deletado com estrat√©gia ${i + 1}`);
                            return;
                        } else if (remainingCount < initialCount) {
                            console.log(`üîÑ Estrat√©gia ${i + 1} deletou ${initialCount - remainingCount} eventos`);
                        }

                    } catch (strategyError) {
                        console.warn(`‚ö†Ô∏è Estrat√©gia ${i + 1} falhou:`, strategyError);
                    }
                }

                // Se chegou aqui, nenhuma estrat√©gia funcionou completamente
                const { count: finalCount } = await supabase
                    .from('service_events')
                    .select('*', { count: 'exact', head: true });

                results.push(`‚ùå ${tableInfo.name}: Ainda restam ${finalCount || 0} eventos ap√≥s todas as estrat√©gias`);

            } catch (error) {
                console.error('Erro cr√≠tico na estrat√©gia especial:', error);
                results.push(`‚ùå ${tableInfo.name}: Erro cr√≠tico - ${error.message}`);
            }
        }

        // Fun√ß√£o para executar limpeza SQL direta
        window.executeSQLCleanup = async function() {
            const progressContent = document.getElementById('progressContent');

            const confirmation = confirm(
                'üî• LIMPEZA FOR√áADA DIRETA\n\n' +
                'Esta √© a abordagem mais agressiva!\n' +
                'Vai deletar tabela por tabela na ordem correta.\n\n' +
                '‚ö†Ô∏è TODOS OS DADOS SER√ÉO PERMANENTEMENTE REMOVIDOS!\n\n' +
                'Tem ABSOLUTA CERTEZA que deseja continuar?'
            );

            if (!confirmation) {
                return;
            }

            const progressDiv = document.getElementById('progress');
            progressDiv.style.display = 'block';

            try {
                progressContent.innerHTML = '<div class="loading">üî• Iniciando limpeza for√ßada...</div>';

                // Lista de tabelas na ordem correta para exclus√£o
                const tablesToClean = [
                    { name: 'Coment√°rios', table: 'service_order_comments' },
                    { name: 'Progresso', table: 'service_order_progress' },
                    { name: 'Imagens', table: 'service_order_images' },
                    { name: 'Transa√ß√µes', table: 'financial_transactions' },
                    { name: 'Agendamentos', table: 'agendamentos_ai' },
                    { name: 'Eventos', table: 'service_events' },
                    { name: 'Ordens', table: 'service_orders' },
                    { name: 'Clientes', table: 'clients' }
                ];

                let results = [];

                for (let i = 0; i < tablesToClean.length; i++) {
                    const tableInfo = tablesToClean[i];

                    try {
                        progressContent.innerHTML = `<div class="loading">üóëÔ∏è ${i + 1}/${tablesToClean.length}: Deletando ${tableInfo.name}...</div>`;

                        // Estrat√©gia especial para service_events (mais agressiva)
                        if (tableInfo.table === 'service_events') {
                            await handleServiceEventsSpecial(tableInfo, results);
                            continue;
                        }

                        // Estrat√©gia m√∫ltipla para outras tabelas
                        let deleted = false;
                        let attempts = 0;
                        const maxAttempts = 3;

                        while (!deleted && attempts < maxAttempts) {
                            attempts++;

                            try {
                                // Tentar diferentes abordagens
                                let deleteResult;

                                if (attempts === 1) {
                                    // Tentativa 1: Deletar todos
                                    deleteResult = await supabase
                                        .from(tableInfo.table)
                                        .delete()
                                        .neq('id', '00000000-0000-0000-0000-000000000000');
                                } else if (attempts === 2) {
                                    // Tentativa 2: Deletar com condi√ß√£o diferente
                                    deleteResult = await supabase
                                        .from(tableInfo.table)
                                        .delete()
                                        .not('id', 'is', null);
                                } else {
                                    // Tentativa 3: Deletar com condi√ß√£o de data
                                    deleteResult = await supabase
                                        .from(tableInfo.table)
                                        .delete()
                                        .gte('created_at', '1900-01-01T00:00:00Z');
                                }

                                if (!deleteResult.error) {
                                    // VERIFICA√á√ÉO REAL: Contar quantos registros restam
                                    const { count: remainingCount } = await supabase
                                        .from(tableInfo.table)
                                        .select('*', { count: 'exact', head: true });

                                    if (!remainingCount || remainingCount === 0) {
                                        deleted = true;
                                        results.push(`‚úÖ ${tableInfo.name}: Realmente deletado (tentativa ${attempts})`);
                                    } else {
                                        console.warn(`${tableInfo.table} ainda tem ${remainingCount} registros ap√≥s "sucesso"`);
                                        if (attempts === maxAttempts) {
                                            results.push(`‚ùå ${tableInfo.name}: Ainda restam ${remainingCount} registros`);
                                        }
                                    }
                                } else {
                                    console.warn(`Tentativa ${attempts} falhou para ${tableInfo.table}:`, deleteResult.error);
                                    if (attempts === maxAttempts) {
                                        results.push(`‚ùå ${tableInfo.name}: ${deleteResult.error.message}`);
                                    }
                                }

                            } catch (attemptError) {
                                console.warn(`Exce√ß√£o na tentativa ${attempts} para ${tableInfo.table}:`, attemptError);
                                if (attempts === maxAttempts) {
                                    results.push(`‚ö†Ô∏è ${tableInfo.name}: ${attemptError.message}`);
                                }
                            }

                            // Pausa entre tentativas
                            if (!deleted && attempts < maxAttempts) {
                                await new Promise(resolve => setTimeout(resolve, 1000));
                            }
                        }

                    } catch (tableError) {
                        results.push(`‚ùå ${tableInfo.name}: ${tableError.message}`);
                    }

                    // Pausa entre tabelas
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                progressContent.innerHTML = `
                    <div class="success">
                        <strong>üî• Limpeza for√ßada conclu√≠da!</strong><br><br>
                        <strong>Resultados:</strong>
                        <ul>
                            ${results.map(result => `<li>${result}</li>`).join('')}
                        </ul>
                    </div>
                `;

                // Verifica√ß√£o final
                setTimeout(async () => {
                    try {
                        const { count: ordersLeft } = await supabase
                            .from('service_orders')
                            .select('*', { count: 'exact', head: true });

                        const { count: clientsLeft } = await supabase
                            .from('clients')
                            .select('*', { count: 'exact', head: true });

                        progressContent.innerHTML += `
                            <div class="success">
                                <br><strong>üìä Verifica√ß√£o Final:</strong><br>
                                Ordens restantes: ${ordersLeft || 0}<br>
                                Clientes restantes: ${clientsLeft || 0}<br><br>
                                ${(ordersLeft || 0) === 0 && (clientsLeft || 0) === 0 ?
                                    'üéâ <strong>LIMPEZA COMPLETA REALIZADA COM SUCESSO!</strong>' :
                                    '‚ö†Ô∏è Alguns dados podem n√£o ter sido removidos'}
                            </div>
                        `;

                        if ((ordersLeft || 0) === 0 && (clientsLeft || 0) === 0) {
                            document.getElementById('storageBtn').style.display = 'inline-block';
                            document.getElementById('sqlCleanBtn').style.display = 'none';
                            document.getElementById('cleanBtn').style.display = 'none';
                        }

                    } catch (verifyError) {
                        console.error('Erro na verifica√ß√£o final:', verifyError);
                    }
                }, 2000);

            } catch (error) {
                console.error('Erro na limpeza SQL:', error);
                progressContent.innerHTML = `<div class="error">Erro durante a limpeza SQL: ${error.message}</div>`;
            }
        }

        // Fun√ß√£o para limpar Storage
        window.cleanStorage = async function() {
            const progressContent = document.getElementById('progressContent');

            const confirmation = confirm(
                'üìÅ LIMPEZA DO STORAGE\n\n' +
                'Esta a√ß√£o ir√° remover todas as imagens e arquivos relacionados √†s ordens de servi√ßo.\n\n' +
                'Continuar?'
            );

            if (!confirmation) {
                return;
            }

            try {
                let storageResults = [];

                // Lista de buckets para limpar
                const bucketsToClean = [
                    { name: 'service-images', label: 'Imagens das Ordens' },
                    { name: 'qr-codes', label: 'QR Codes' },
                    { name: 'client-documents', label: 'Documentos de Clientes' }
                ];

                for (const bucket of bucketsToClean) {
                    try {
                        progressContent.innerHTML = `<div class="loading">Limpando ${bucket.label}...</div>`;

                        // Listar arquivos no bucket
                        const { data: files, error: listError } = await supabase.storage
                            .from(bucket.name)
                            .list();

                        if (listError) {
                            console.warn(`Bucket ${bucket.name} n√£o encontrado:`, listError);
                            continue;
                        }

                        if (!files || files.length === 0) {
                            storageResults.push(`${bucket.label}: 0 arquivos (bucket vazio)`);
                            continue;
                        }

                        // Deletar todos os arquivos
                        const filePaths = files.map(file => file.name);
                        const { error: deleteError } = await supabase.storage
                            .from(bucket.name)
                            .remove(filePaths);

                        if (deleteError) {
                            console.error(`Erro ao deletar arquivos de ${bucket.name}:`, deleteError);
                            storageResults.push(`${bucket.label}: Erro ao remover arquivos`);
                        } else {
                            storageResults.push(`${bucket.label}: ${files.length} arquivos removidos`);
                        }

                    } catch (error) {
                        console.warn(`Erro ao processar bucket ${bucket.name}:`, error);
                        storageResults.push(`${bucket.label}: Bucket n√£o encontrado ou erro`);
                    }
                }

                progressContent.innerHTML = `
                    <div class="success">
                        <strong>üéâ LIMPEZA COMPLETA FINALIZADA!</strong><br><br>
                        <strong>Storage limpo:</strong>
                        <ul>
                            ${storageResults.map(result => `<li>${result}</li>`).join('')}
                        </ul>
                        <br>
                        <div class="success">
                            <strong>‚úÖ PROCESSO CONCLU√çDO COM SUCESSO!</strong><br><br>
                            <strong>Resumo da limpeza completa:</strong>
                            <ul>
                                <li>‚úÖ Backup criado e salvo</li>
                                <li>‚úÖ Banco de dados limpo</li>
                                <li>‚úÖ Storage limpo</li>
                                <li>‚úÖ Sistema pronto para uso</li>
                            </ul>
                            <br>
                            <strong>üöÄ O sistema Fix Fog√µes est√° agora completamente limpo e pronto para novos dados!</strong>
                        </div>
                    </div>
                `;

                // Esconder bot√£o do storage
                document.getElementById('storageBtn').style.display = 'none';

            } catch (error) {
                console.error('Erro na limpeza do storage:', error);
                progressContent.innerHTML = `<div class="error">Erro durante a limpeza do storage: ${error.message}</div>`;
            }
        }

        async function getGeneralCounts() {
            const section = document.createElement('div');
            section.className = 'section';
            
            try {
                // Contar ordens de servi√ßo
                const { count: ordersCount, error: ordersError } = await supabase
                    .from('service_orders')
                    .select('*', { count: 'exact', head: true });
                
                if (ordersError) throw ordersError;
                
                // Contar clientes
                const { count: clientsCount, error: clientsError } = await supabase
                    .from('clients')
                    .select('*', { count: 'exact', head: true });
                
                if (clientsError) throw clientsError;
                
                return `
                    <div class="section">
                        <h2>Contagem Geral de Registros</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${ordersCount || 0}</div>
                                <div class="stat-label">Ordens de Servi√ßo</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${clientsCount || 0}</div>
                                <div class="stat-label">Clientes</div>
                            </div>
                        </div>
                    </div>
                `;
                
            } catch (error) {
                return `<div class="error">Erro ao obter contagem geral: ${error.message}</div>`;
            }
        }

        async function getDependenciesAnalysis() {
            try {
                // Contar depend√™ncias
                const dependencies = await Promise.all([
                    countTable('service_order_images', 'Imagens das Ordens'),
                    countTable('service_order_comments', 'Coment√°rios'),
                    countTable('service_order_progress', 'Registros de Progresso'),
                    countTable('financial_transactions', 'Transa√ß√µes Financeiras'),
                    countTable('agendamentos_ai', 'Agendamentos AI'),
                ]);
                
                let html = `
                    <div class="section">
                        <h2>An√°lise de Depend√™ncias</h2>
                        <div class="stats-grid">
                `;
                
                dependencies.forEach(dep => {
                    html += `
                        <div class="stat-card">
                            <div class="stat-number">${dep.count}</div>
                            <div class="stat-label">${dep.label}</div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
                
                return html;
                
            } catch (error) {
                return `<div class="error">Erro ao analisar depend√™ncias: ${error.message}</div>`;
            }
        }

        async function countTable(tableName, label) {
            try {
                const { count, error } = await supabase
                    .from(tableName)
                    .select('*', { count: 'exact', head: true });
                
                if (error) throw error;
                return { count: count || 0, label };
            } catch (error) {
                console.warn(`Erro ao contar ${tableName}:`, error);
                return { count: 0, label };
            }
        }

        async function getClientsAnalysis() {
            try {
                // Clientes com usu√°rio
                const { count: withUser, error: withUserError } = await supabase
                    .from('clients')
                    .select('*', { count: 'exact', head: true })
                    .not('user_id', 'is', null);
                
                // Clientes sem usu√°rio
                const { count: withoutUser, error: withoutUserError } = await supabase
                    .from('clients')
                    .select('*', { count: 'exact', head: true })
                    .is('user_id', null);
                
                return `
                    <div class="section">
                        <h2>An√°lise de Clientes</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="stat-number">${withUser || 0}</div>
                                <div class="stat-label">Com Conta de Usu√°rio</div>
                            </div>
                            <div class="stat-card">
                                <div class="stat-number">${withoutUser || 0}</div>
                                <div class="stat-label">Sem Conta de Usu√°rio</div>
                            </div>
                        </div>
                    </div>
                `;
                
            } catch (error) {
                return `<div class="error">Erro ao analisar clientes: ${error.message}</div>`;
            }
        }

        async function getStatusAnalysis() {
            try {
                const { data, error } = await supabase
                    .from('service_orders')
                    .select('status')
                    .not('status', 'is', null);
                
                if (error) throw error;
                
                const statusCounts = {};
                data.forEach(order => {
                    statusCounts[order.status] = (statusCounts[order.status] || 0) + 1;
                });
                
                let html = `
                    <div class="section">
                        <h2>Ordens por Status</h2>
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Status</th>
                                    <th>Quantidade</th>
                                    <th>Percentual</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                const total = data.length;
                Object.entries(statusCounts)
                    .sort(([,a], [,b]) => b - a)
                    .forEach(([status, count]) => {
                        const percentage = ((count / total) * 100).toFixed(1);
                        html += `
                            <tr>
                                <td>${status}</td>
                                <td>${count}</td>
                                <td>${percentage}%</td>
                            </tr>
                        `;
                    });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                return html;
                
            } catch (error) {
                return `<div class="error">Erro ao analisar status: ${error.message}</div>`;
            }
        }

        async function getAttendanceTypeAnalysis() {
            try {
                const { data, error } = await supabase
                    .from('service_orders')
                    .select('attendance_type')
                    .not('attendance_type', 'is', null);
                
                if (error) throw error;
                
                const typeCounts = {};
                data.forEach(order => {
                    typeCounts[order.attendance_type] = (typeCounts[order.attendance_type] || 0) + 1;
                });
                
                let html = `
                    <div class="section">
                        <h2>Ordens por Tipo de Atendimento</h2>
                        <table class="table">
                            <thead>
                                <tr>
                                    <th>Tipo de Atendimento</th>
                                    <th>Quantidade</th>
                                    <th>Percentual</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                const total = data.length;
                Object.entries(typeCounts)
                    .sort(([,a], [,b]) => b - a)
                    .forEach(([type, count]) => {
                        const percentage = ((count / total) * 100).toFixed(1);
                        html += `
                            <tr>
                                <td>${type}</td>
                                <td>${count}</td>
                                <td>${percentage}%</td>
                            </tr>
                        `;
                    });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                return html;
                
            } catch (error) {
                return `<div class="error">Erro ao analisar tipos de atendimento: ${error.message}</div>`;
            }
        }

        async function getFinalSummary() {
            try {
                // Obter contagens finais
                const { count: totalOrders } = await supabase
                    .from('service_orders')
                    .select('*', { count: 'exact', head: true });
                
                const { count: totalClients } = await supabase
                    .from('clients')
                    .select('*', { count: 'exact', head: true });
                
                const { count: totalImages } = await supabase
                    .from('service_order_images')
                    .select('*', { count: 'exact', head: true });
                
                let warningClass = 'success';
                let warningText = '‚úÖ Nenhum dado encontrado para remo√ß√£o.';
                
                if ((totalOrders || 0) > 0 || (totalClients || 0) > 0) {
                    warningClass = 'warning';
                    warningText = `‚ö†Ô∏è ATEN√á√ÉO: ${totalOrders || 0} ordens de servi√ßo e ${totalClients || 0} clientes ser√£o PERMANENTEMENTE removidos!`;
                }
                
                return `
                    <div class="section">
                        <h2>Resumo Final</h2>
                        <div class="${warningClass}">
                            <strong>${warningText}</strong>
                            <br><br>
                            <strong>Dados que ser√£o removidos:</strong>
                            <ul>
                                <li>Ordens de servi√ßo: ${totalOrders || 0}</li>
                                <li>Clientes: ${totalClients || 0}</li>
                                <li>Imagens: ${totalImages || 0}</li>
                                <li>Todos os dados relacionados (coment√°rios, progresso, transa√ß√µes, etc.)</li>
                            </ul>
                            <br>
                            <strong>üìã Revise cuidadosamente antes de prosseguir com a limpeza!</strong>
                        </div>
                    </div>
                `;
                
            } catch (error) {
                return `<div class="error">Erro ao gerar resumo final: ${error.message}</div>`;
            }
        }
    </script>
</body>
</html>
